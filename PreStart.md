# 控制台游戏引擎设计草案
---
## 大概要实现的功能
- 尽量用C语言实现
- 有较可拓展的主循环
- 有简单的UI层，主要用于显示内容（输入由键盘键入）
- UI最好可以实现按钮选择样式的上下移动
- 主要适用于走迷宫式游戏（优先），最好可以兼容2D风格的RPG类型
- 实现简单的重力与不依托于重力的简单碰撞系统
- 实现玩家与敌人的基本行为逻辑
- 敌人最好有简单的AI判断模式
- 可以与场景物体进行不同的交互
- 通过清空和重新绘制实现60帧刷新
- 最好实现全屏按坐标绘制
- 实现两三个关卡的关卡选择

## 大概实现步骤
- 实现程序主循环
- 实现实时键盘输入
- 实现按坐标刷新命令窗口
- 实现关卡场景记录以及呈现
- 加入玩家并实现初始化
- 加入敌人（可以的话实现简单AI）
- 加入玩家与敌人的互相攻击
- 加入UI层
- 加入开始界面
- 加入关卡选择

备注：getch返回值
- w：119
- a：97
- s：115
- d：100
- f：102
- space：32
- j：106
- k：107
- l：108
- i：105
- esc：27

---

## 实现

### 将 Init Update TurnOff 剥离出来
按不同的子系统的初始化、更新和关闭抽离出来

### 将字符写入缓冲区
    char text[5];
    strcpy_s(text, 5 * sizeof(char), "バカ");
    ClearOutputBuffer();
    for (int i = 0; i < 4; i++)
    {
        g_OutputBuffer[5][i + test] = text[i];
    }
    test++;
用这种方式实现（虽然很蠢）

### 将输入使用多线程重构，或者使用别的类似的方式代替
对输入的字符进行储存，然后在某一阶段对其进行统一处理
以实现，以链表形式实现，可通过DefinedValues.h的宏定义实现是自刷新还是按键刷新

### 实现简易并且较可拓展的UI系统
- 提供编号
- 确定位置并提供父子物体位置关系
- UI面板及其长宽
- 按钮样式及文字（只能选择最上层的按钮进行操作）
- 按键选择效果
- 字符串显示

#### 多线程输出控制台图像
实现双重缓冲，如果内容没有变则不进行绘制
声明一个指向性指针，在draw的时候检查两个缓冲有没有不同
没有的话跳过渲染输出的过程,但仍然进行指针交换
添加一个获取用于渲染的GetOutputBuffer
目前是做到了，但似乎最好再开一个开一个线程去把渲染和更新分开，需要等待
使用多线程输出确实可以在算力较低的CPU上确实可以做到相对流畅的效果
但会出现很多奇奇怪怪的bug，可能后期需要重构或者废弃

#### 按键实现
根据字符长度决定按钮长度并添加边框
位置与字符串与函数指针
根据位置写入二维数组
放弃了二维数组，预计使用指针实现
字色与背景色颜色反转，并在两边添加星号
可以记录当前被选的按钮（利用最上层UIO实现）
获取上下左右移动的按钮然后在数组中选择相应的按钮
还是用switch来实现吧过于麻烦了，有机会再重构

已经写好了选择按键，接下来是使用按键的方法实现以及基础碰撞系统
返回一个状态值，根据这个状态值switch对应的方法
需要有的固定方法：打开或者创建某个UIO，操作某个物体

### 实现简易碰撞
先写一个Object的基础结构体用于确定位置，然后先进行游戏本体文件夹的编写

### 实现游戏逻辑单独文件夹
要有独立的初始化、更新物体的功能，更新完成后通过GameApp绘制到更新用缓存
首先实现一个简单的标题界面
实现一个人物到处移动，加入UI部分
加入地图并聚焦在人物之上
加入碰撞使得人物不能超过墙壁的范围
加入敌人并实现简单的：发现——接近——碰撞展开攻击
暂时告一段落，准备进行打斗场景的实现

#### 场景node结构体
场景编号、场景名字、基础UIO、摄像头位置、摄像头高宽（以缓存形式的摄像头）
场景基本实现，接下来是玩家、建筑、敌人实体的实现并与场景的更新协调起来

基本的实现预估：
维护几个实体数组，并都包含Object结构体，提供初始化、更新、绘制至缓冲、结束的方法
在绘制场景方法执行前将这些内容绘制到摄像机缓冲当中
几个实体数组（按实现顺序）:
player - map - wall(依附于map) - start/end - 
enemy - item（感觉可以不用，先写battleStage吧）
写enemy的时候最好给mapbuffer加一个使用POSITION2D来查询内容物的方法，
再通过适当的寻路算法进行动态追踪玩家
如果实在实现困难的话就用测同一直线上是否有路障，有的话靠近，没有的话停留，
草追踪有点麻烦，静态寻路用不了，BDFS有点慢有可能造成掉帧，
先用最简单的实现着先，以后有机会再重构

Enemy:object+sprite+visible
InitEnemy()
对数组进行初始化赋值
UpdateEnemy()
对数组中可见的敌人进行遍历更新，调用UpdateSingleEnemy
UpdateSingleEnemy(ENEMY* enemy)
调用ScanPlaer(ENEMY* enemy)
调用ManageEnemyMove(ENEMY* enemy, int scanFlag)
将此enemy绘制到cam缓冲
计算与player是否碰撞，目前碰撞则输出log
int ScanPlaer(ENEMY* enemy)
以宽度为5，长度为15的标准对玩家object进行检测，
如果为真则根据deltaXY的正负大小关系设置scanFlag为1234
并且object此时需要追加返回XY距离的函数
ManageEnemyMove(ENEMY* enemy, int scanFlag)
根据scanFlag做不同处理，若不为0则分别调用相应的移动函数EnemyMoveFBLR()
若为0则查看movingFlag是否为0，若为0则随机生成移动方向并赋值给movingFlag，
生成时循环生成直至检测到可以移动（参考player移动），若不为0则调用相应的移动函数
EnemyMoveFBLR()
参考player移动，但若撞墙则将movingFlag设置为0

在AppUpdate或者UpdateCurrScene当中进行更新
定义一个绘制flag用于以不同的颜色绘制特殊的实体，consoleprint中添加一个后处理方法
此后处理方法提供由GameApp中的客制化app提供
